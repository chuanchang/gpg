---
title: "Using GPG in R"
author: "Jeroen Ooms"
output:
  html_document:
    fig_caption: false
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Using GPG in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
unlink("~/myapp", recursive = TRUE)
knitr::opts_chunk$set(comment = "")
library(gpg)
```


The *GNU Privacy Guard*, also known as *GnuPG* or simply *GPG*, is a popular open source implementation of the OpenPGP protocol ([RFC4880](https://tools.ietf.org/html/rfc4880)). The system is widely adopted for securing integrity and confidentiality of internet communications through the use of various cryptographic methods. Important applications include encryption and authentication of messages (such as email or software downloads) via public key encryption and cryptographic signatures.

## GPG basics

Like most modern crypto systems, GPG makes use of public key methods. The private key is known only by its owner and is used to create signatures or decrypt a message. The corresponding public key is made freely available and so that it can be used by anyone to verify signatures, or encrypt messages which can only be encrypted by the keypair owner. 

### Compare to HTTPS

The major difference between GPG and PKI systems (such as HTTPS) is how we exchange and authenticate public keys. HTTPS is based on a system with Certificate Authorities (CA). Anyone can create a keypair for any domain/personal name, however we only trust public keys which have been signed by an official CA. 

This CA is typically a commercial vendor which verifies your identity (e.g. via a copy of your passport) and then uses their own keypair to sign a certificate containing your name and public key. The public keys of CA's are hardcoded in HTTP clients. The main disadvantage is that CA's are expensive and everything collapses if any of them is compromised or not doing their job well.

### The web of trust

GPG uses a different system which does not rely on authorities. In GPG, peers sign each other's keys, and it is up to the user to manage who they choose to trust in their personal keyring. For any given signature, GPG will check if it was created by a trusted party in the keyring, or by a third party which has been verified by someone in the keyring, and so on: a "web of trust".

The easiest way to exchange (signed or unsigned) public keys is via a keyserver. GPG is compatible with existing PGP key servers. These servers mirror each other so most keys are available on either one.

 - https://pgp.mit.edu
 - https://keyserver.ubuntu.com
 - http://keys.gnupg.net

GPG key servers might not use HTTPS. In GPG we only trust keys only on basis of who has signed them, regardless of how they were obtained. For this reason it is also perfectly valid to share GPG public keys via e.g. a website or email.

## Managing your keyring

It is important to know which version of GPG you are running and where your home dir is. Your home directory contains your configuration and the keyrings. GPG defaults to your system keyring, which is the same as the `gpg` command line utility and system package manager use.

```{r}
str(gpg_info())
```

Use `gpg_restart` to switch to another GPG executable or different home directory, e.g. to build an application which uses its own configuration and keyrings:

```{r}
gpg_restart(home = "~/myapp")
```


Use `gpg_list_keys()` and `gpg_list_secret_keys()` to see the current contents of your keyring:

```{r}
gpg_list_keys()[c("id", "name", "email")]
gpg_list_secret_keys()[c("id", "name", "email")]
```

### Generating keys

Use `gpg_keygen()` to generate a new public private keypair:

```{r}
(mykey <- gpg_keygen(name = "Jerry", email = "jerry@gmail.com"))
gpg_list_keys()[c("id", "name", "email")]
```


### Importing a key

The `gpg_import` function reads an armored GPG key from disk:

```{r}
curl::curl_download("https://stallman.org/rms-pubkey.txt", "rms-pubkey.txt")
gpg_import("rms-pubkey.txt")
unlink("rms-pubkey.txt")
```

### Download from keyserver

Use the `gpg_recv` function to download a given key ID from the keyserver. For example let's import the public key from Michael Rutter which is used to [sign the Ubuntu r-base packages](https://cran.r-project.org/bin/linux/ubuntu/README.html) from CRAN:

```{r}
gpg_recv(id ="E084DAB9")
keyring <- gpg_list_keys()
keyring[c("id", "name", "email")]
```

Note that for imported keys, we do not have the private key:

```{r}
secring <- gpg_list_secret_keys()
secring[c("id", "name", "email")]
```

### Exporting a key

To export our newly created public key:

```{r}
str <- gpg_export(id = mykey)
cat(str)
```

If you also own the private key you can export this as well:

```{r}
str <- gpg_export(id = mykey, secret = TRUE)
cat(str)
```

### Deleting a key

Delete a key from its ID or fingerprint. Let's delete the RMS key:

```{r}
gpg_delete('2C6464AF2A8E4C02')
gpg_list_keys()[c("id", "name", "email")]
```


## Digital Signatures

A digital signature is a mathematical scheme for demonstrating the authenticity of a digital message or document. If you sign a file using your personal secret key, anyone can verify that this file has not been modified (i.e. the hash matches the one in your signture) via your public key.

GPG signatures are widely used by Linux package managers such as `apt` to verify the integrity of downloaded files. Typically the public key is shipped with the OS, and the private key is owned by the repository maintainers. This way we can safely install software from any mirror or network.

### Signing a file

Let's use the private key we generated earlier to sign a file:

```{r}
myfile <- tempfile()
writeLines("This is a secret message", con = myfile)
sig <- gpg_sign(myfile, mykey)
cat(sig)
writeLines(sig, "myfile.sig")
```

### Verify a signature

The `gpg_verify` function will see if a signature is valid for any of the keys in the keyring:

```{r}
gpg_verify(myfile, signature = "myfile.sig")
unlink("myfile.sig")
```


## Encryption

GPG uses public key encryption. You can use someone's public key to encrypt a message or document, in a way that only the owner of the corresponding private key will be able to decrypt.

This is a great way to send someone a highly confidential email. 

### Encrypting a message

For example we want to send an email [Glenn Greenwald](https://theintercept.com/staff/glenn-greenwald/) containing top secret information that may not be snooped by our ISP or government. His homepage at the intercept shows his GPG key in long form.

```{r}
glenn <- '734A3680A438DD45AF6F5B99A4A928C769CD6E44'
gpg_recv(glenn)
writeLines("TTIP is super evil!", "secret.txt")
msg <- gpg_encrypt("secret.txt", glenn)
writeLines(msg, "msg.gpg")
unlink("secret.txt")
cat(msg)
```

You can safely send this message over any channel (email, twitter, etc). Nobody in the world (not even ourselves) will be able to decipher this message, except for Glenn Greenwald.

### Decrypting a message

Decrypting a message is even easier, you don't have to specify a key. GPG will automatically pick the correct private key from your keyring, and error if you don't have it. For example we will not be able to decrypt the message we created above for Glenn Greenwald.

```{r, error=TRUE}
# This will error, we do not have this private key
gpg_decrypt("msg.gpg")
```

To demonstrate decryption, we encrypt a message using our own keypair (for which we own the private key).

```{r}
writeLines("This is a test!", "secret.txt")
msg <- gpg_encrypt("secret.txt", id = mykey)
writeLines(msg, "msg.gpg")
unlink("secret.txt")
cat(msg)
```

Decryption is simple:

```{r}
gpg_decrypt("msg.gpg")
unlink("msg.gpg")
```